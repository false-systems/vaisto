; Vaisto State Module
; Provides mutable state via process dictionary
;
; The process dictionary is process-local mutable storage.
; While not purely functional, it's useful for:
; - Compiler passes that accumulate state (errors, warnings, symbol tables)
; - Unique ID generation (gensym)
; - Caching during traversals
;
; Note: This breaks referential transparency. Use sparingly and locally.

(ns Std.State)

; --- Erlang FFI ---

; Get value from process dictionary
(extern erlang/get [:any] :any)

; Put value in process dictionary (returns old value or :undefined)
(extern erlang/put [:any :any] :any)

; Erase key from process dictionary
(extern erlang/erase [:any] :any)

; Get all keys in process dictionary
(extern erlang/get_keys [] (List :any))

; Get entire process dictionary as list of tuples
(extern erlang/get [] (List :any))

; Erase entire process dictionary
(extern erlang/erase [] (List :any))

; Additional Erlang FFI
(extern erlang/binary_to_atom [:string] :atom)
(extern erlang/iolist_to_binary [(List :any)] :string)
(extern erlang/atom_to_binary [:atom] :string)
(extern erlang/integer_to_binary [:int] :string)
(extern lists/reverse [(List :any)] (List :any))

; Tuple accessors
(extern erlang/element [:int :any] :any)

; --- High-level API ---

; Get a value by key, returning Option
; (get :my-key) -> (Some value) | None
(defn get [key]
  (match (erlang/get key)
    [:undefined (None)]
    [val (Some val)]))

; Get a value with default
; (get-or :my-key 0) -> value or 0
(defn get-or [key default]
  (match (erlang/get key)
    [:undefined default]
    [val val]))

; Set a value, returns the old value as Option
; (set! :my-key "value") -> (Some old) | None
(defn set! [key value]
  (match (erlang/put key value)
    [:undefined (None)]
    [old (Some old)]))

; Delete a key, returns its old value as Option
; (delete! :my-key) -> (Some old) | None
(defn delete! [key]
  (match (erlang/erase key)
    [:undefined (None)]
    [old (Some old)]))

; Check if key exists
; (has? :my-key) -> bool
(defn has? [key]
  (match (erlang/get key)
    [:undefined false]
    [_ true]))

; Update a value with a function
; (update! :counter inc) -> new-value
(defn update! [key f]
  (let [old (get-or key :undefined)
        new (f old)]
    (set! key new)
    new))

; --- Compiler-specific helpers ---

; Generate unique ID (for gensym)
; (unique-id :var) -> :var_0, :var_1, etc.
(defn unique-id [prefix]
  (let [key {:gensym prefix}
        n (get-or key 0)]
    (set! key (+ n 1))
    ; Create symbol like prefix_N
    (erlang/binary_to_atom
      (erlang/iolist_to_binary
        (list (erlang/atom_to_binary prefix)
              "_"
              (erlang/integer_to_binary n))))))

; Simple counter
; (counter-inc! :errors) -> new-count
(defn counter-inc! [name]
  (let [n (get-or name 0)]
    (set! name (+ n 1))
    (+ n 1)))

; Reset counter
; (counter-reset! :errors) -> 0
(defn counter-reset! [name]
  (set! name 0)
  0)

; Accumulate values (like collecting errors)
; (accumulate! :errors {:line 1 :msg "oops"})
(defn accumulate! [key value]
  (let [current (get-or key (list))]
    (set! key (cons value current))))

; Get accumulated values (reversed to original order)
; (get-accumulated :errors) -> list of errors
(defn get-accumulated [key]
  (lists/reverse (get-or key (list))))

; Clear accumulated values
; (clear-accumulated! :errors) -> old-values
(defn clear-accumulated! [key]
  (let [old (get-accumulated key)]
    (set! key (list))
    old))

; --- Tuple helpers ---

; Get first element of a tuple (index 1 in Erlang)
(defn fst [tuple]
  (erlang/element 1 tuple))

; Get second element of a tuple (index 2 in Erlang)
(defn snd [tuple]
  (erlang/element 2 tuple))

; Apply function to each element of a list (for side effects)
(defn for-each [f xs]
  (match xs
    [[] :ok]
    [[h | t]
      (f h)
      (for-each f t)]))

; --- Scoped state ---

; Run a function with isolated state
; Any changes to process dictionary are reverted after
; (with-isolated-state (fn [] ... ))
(defn with-isolated-state [f]
  (let [saved (erlang/get)
        result (f)]
    ; Restore old state
    (erlang/erase)
    (for-each (fn [kv] (erlang/put (fst kv) (snd kv))) saved)
    result))

; Run with specific initial bindings
; (with-state {:debug true :level 0} (fn [] ...))
(defn with-state [bindings f]
  (with-isolated-state
    (fn []
      (for-each (fn [kv] (set! (fst kv) (snd kv))) bindings)
      (f))))
